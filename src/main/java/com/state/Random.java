package com.state;

import com.functional.Tuple;
import com.functional.Function;

import com.util.List;

/**
 * A utility interface to random number generation. This interface defines
 * a set of utility functions, that allow one to do repeatable comptuations
 * on the Random numbers. All the functions in this interface return a function
 * taking the RNG as a parameter, so the clients can plug any Random number
 * generator (based on various implementations).
 * @param <A>: The type parameter of the Random elements.
 */
public interface Random<A> extends Function<RNG, Tuple<A, RNG>>{
    Random<Integer> integer = RNG::nextInt;

    /**
     * Construct a Random object from a fixed values.
     * @param a : The value to be encapsulated.
     * @param <A> : Type parameter of the element.
     * @return the Random function, which can generate a sequence of values.
     */
    static <A> Random<A> unit(A a) {
        return rng -> Tuple.create(a, rng);
    }

    /**
     * This function transforms the randomly generated value to another type.
     * @param a : Random generator of type A
     * @param f: Function that maps an A to a B.
     * @param <A> : Type parameter A
     * @param <B> : Type parameter B
     * @return the transformed Random generator of type B.
     */
    static <A, B> Random<B> map(Random<A> a, Function<A, B> f) {
        return rng -> {
            var res = a.apply(rng);
            return Tuple.create(f.apply(res._1), res._2);
        };
    }

    Random<Boolean> booleanRnd = Random.map(integer, i -> i % 2 == 0);
    
    Random<Double> doubleRnd = Random.map(integer, d -> d / (((double) Integer.MAX_VALUE) + 1.0));

    /**
     * This is a convenience function to map two random generators into a third
     * generator.
     * @param a  : Random generator of type A.
     * @param b : Random generator of type B.
     * @param f : A curried function that takes values of type A and B and returns
     *          a value of type B.
     * @param <A> : Type parameter A.
     * @param <B> : Type parameter B.
     * @param <C> : Type parameter C.
     * @return the transformed Random generator of type C.
     */
    static <A, B, C> Random<C> map2(Random<A> a, Random<B> b, Function<A, Function<B, C>> f) {
        return rng -> {
            var res1 = a.apply(rng);
            var res2 = b.apply(res1._2);

            return Tuple.create(f.apply(res1._1).apply(res2._1), res2._2);
        };
    }

    Random<Tuple<Integer, Integer>> intPairRnd = map2(integer, integer, x -> y -> Tuple.create(x,y));

    /**
     * This function transforms a List<Random<A> into a Random<List<A>>. It basically
     * swaps the containers List and Random.
     * @param rs : The list of random generators.
     * @param <A> : Type parameter of random values to be generated by random generators.
     * @return the generator that can generate a list of random values.
     */
    static <A> Random<List<A>> sequence(List<Random<A>> rs) {
        return rs.foldLeft(unit(List.list()), acc -> v -> map2(acc, v, ls -> l -> ls.cons(l)));
    }

    Function<Integer, Random<List<Integer>>> integersRnd = length -> sequence(List.fill(length, () -> integer));

    /**
     * This function allows to repeatedly apply an RNG and return the final value.
     * @param a : Random gnerator of type A.
     * @param f : A function that accepts a random value of type A and return a 
     *          Random generator of type B.
     * @param <A>
     * @param <B>
     * @return
     */
    static <A,B> Random<B> flatMap(Random<A> a, Function<A, Random<B>> f) {
        return rng -> {
            var res = a.apply(rng);
            return f.apply(res._1).apply(res._2);
        };
    }
    
    Random<Integer> notMultipleOfFiveRnd = Random.flatMap(integer, x -> {
        int mod = x % 5;
        return mod != 0 ? unit(mod) : Random.notMultipleOfFiveRnd;
    });
}


