package com.state;

import com.functional.Tuple;
import com.functional.Function;

import com.util.List;

/**
 * A utility class to handle state mutations functionally. It defines the
 * standard set of functions like unit, flatMap, map, map2 and sequence to allow
 * clients to handle state mutations without explicit side effects.
 * @param <A> : The type parameter of values generated by the state machine.
 * @param <S> : The type parameter of the state machine iteself.
 */
public class State<A,S> {
    /**
     * This member represents the step for doing state mutations, which takes
     * a type representing a state and returns a tuple of value and the next
     * state.
     */
    public final Function<S, Tuple<A, S>> run;

    public State(Function<S, Tuple<A, S>> run ) {
        this.run = run;
    }

    /**
     * Construct a State object from a fixed value. This can act as a seed value
     * for further value computations.
     * @param a : The value to be encapsulated.
     * @param <A>: Type parameter of the element.
     * @param <S> : Type parameter of the State object.
     * @return the State object which can be used to generate more values.
     */
    public static <A, S> State<A, S> unit(A a) {
        return new State<>((S s) -> Tuple.create(a, s));
    }

    /**
     * This general purpose function allows to compose computations that can
     * repeatedly apply the state object and generate values of type B from values
     * of type A.
     * @param f : A function that accpets a seed value of type A and returns a
     *          State object of type B.
     * @param <B> : Type paramter of the resulting value after applying the
     *           function f.
     * @return the State object after applying the given function.
     */
    public <B> State<B, S> flatMap(Function<A, State<B, S>> f) {
        return new State<>( s -> {
            var res = run.apply(s);
            return f.apply(res._1).run.apply(res._2);
        });

    }

    /**
     * This function transforms the value encapsulated by the state object and
     * returns a new state object encapsulating the transformed values.
     * @param f : Function that maps a type from A to B.
     * @param <B> : Type parameter of the result type.
     * @return the transformed state object, encapsulating a value of type B.
     */
    public <B> State<B, S> map(Function<A, B> f) {
        return flatMap(a -> unit(f.apply(a)));
    }

    /**
     * This is a convenience function to transform two values encapsulated by two 
     * state objects into a third type by using the same State generator. 
     * @param rb : State object encapsulating a value of type B.
     * @param f : A curried function that takes values of type A and B and returns
     *          a value of type C.
     * @param <B> : Type parameter B.
     * @param <C> : Type parameter C.
     * @return the transformed State object encapsulating value of type C.
     */
    public <B, C> State<C, S> map2(State<B, S> rb, Function<A, Function<B, C>> f) {
        return flatMap(a -> rb.map(b -> f.apply(a).apply(b)));
    }

    /**
     * This function transforms a List of State values into a State of List values,
     * by repeatedly applying the State  object. The returned State object contains
     * the state object obtained after last application.
     * @param ss : The list of State generators.
     * @param <A> : Type paramter of the values generated by the state generators.
     * @param <S> : Type parameter of the State machine/object.
     * @return the State object holding the list of values and the state object for 
     * further value generation.
     */
    public static <A, S> State<List<A>, S> sequence(List<State<A, S>> ss) {
        return ss.foldRight(unit(List.list()), v -> acc -> v.map2(acc, l -> ls -> ls.cons(l)));
    }
}
