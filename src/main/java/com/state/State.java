package com.state;

import com.functional.Tuple;
import com.functional.Function;

import static com.functional.Tuple.create;

import com.util.List;

/**
 * A utility class to handle state mutations functionally. It defines the
 * standard set of functions like unit, flatMap, map, map2 and sequence to allow
 * clients to handle state mutations without explicit side effects.
 * @param <A> : The type parameter of values generated by the state machine.
 * @param <S> : The type parameter of the state machine itself.
 */
public class State<A,S> {
    /**
     * This member represents the step for doing state mutations, which takes
     * a type representing a state and returns a tuple of value and the next
     * state.
     */
    public final Function<S, Tuple<A, S>> run;

    public State(Function<S, Tuple<A, S>> run ) {
        this.run = run;
    }

    /**
     * Construct a State object from a fixed value. This can act as a seed value
     * for further value computations.
     * @param a : The value to be encapsulated.
     * @param <A>: Type parameter of the element.
     * @param <S> : Type parameter of the State object.
     * @return the State object which can be used to generate more values.
     */
    public static <A, S> State<A, S> unit(A a) {
        return new State<>((S s) -> Tuple.create(a, s));
    }

    /**
     * This general purpose function allows composing computations that can
     * repeatedly apply the state object and generate values of type B from values
     * of type A.
     * @param f : A function that accepts a seed value of type A and returns a
     *          State object of type B.
     * @param <B> : Type parameter of the resulting value after applying the
     *           function f.
     * @return the State object after applying the given function.
     */
    public <B> State<B, S> flatMap(Function<A, State<B, S>> f) {
        return new State<>( s -> {
            var res = run.apply(s);
            return f.apply(res._1).run.apply(res._2);
        });

    }

    /**
     * This function transforms the value encapsulated by the state object and
     * returns a new state object encapsulating the transformed values.
     * @param f : Function that maps a type from A to B.
     * @param <B> : Type parameter of the result type.
     * @return the transformed state object, encapsulating a value of type B.
     */
    public <B> State<B, S> map(Function<A, B> f) {
        return flatMap(a -> unit(f.apply(a)));
    }

    /**
     * This is a convenience function to transform two values encapsulated by two 
     * state objects into a third type by using the same State generator. 
     * @param rb : State object encapsulating a value of type B.
     * @param f : A curried function that takes values of type A and B and returns
     *          a value of type C.
     * @param <B> : Type parameter B.
     * @param <C> : Type parameter C.
     * @return the transformed State object encapsulating value of type C.
     */
    public <B, C> State<C, S> map2(State<B, S> rb, Function<A, Function<B, C>> f) {
        return flatMap(a -> rb.map(b -> f.apply(a).apply(b)));
    }

    /**
     * This function transforms a List of State values into a State of List values,
     * by repeatedly applying the State  object. The returned State object contains
     * the state object obtained after last application.
     * @param ss : The list of State generators.
     * @param <A> : Type parameter of the values generated by the state generators.
     * @param <S> : Type parameter of the State machine/object.
     * @return the State object holding the list of values and the state object for 
     * further value generation.
     */
    public static <A, S> State<List<A>, S> sequence(List<State<A, S>> ss) {
        return ss.foldRight(unit(List.list()), v -> acc -> v.map2(acc, l -> ls -> ls.cons(l)));
    }

    public static <S> State<Nothing, S> sequence(Function<S, S> f) {
        return new State<>(s -> Tuple.create(Nothing.instance, f.apply(s)));
    }
    /**
     * A convenience function which modifies the state and returns it
     * @param f : A function that takes an existing state and returns a new state.
     * @param <S> : Type parameter of the state object.
     * @return the State object with modified state, and a nothing value.
     */
    public static <S> State<Nothing, S> modify(Function<S, S> f) {
        return State.<S>get().flatMap(s -> set(f.apply(s)));
    }

    /**
     * This function returns the argument's state both as the state and the value.
     * @param <S> : The type parameter of the state object.
     * @return a state object whose state and value are both the passed in state
     * object type to the run function.
     */
    public static <S> State<S, S> get() {
        return new State<>(s -> Tuple.create(s, s));
    }

    /**
     * This function returns the parameter's state as the new state and the
     * Nothing singleton as the value.
     * @param s : The state object to be encapsulated.
     * @param <S> : Type parameter of the state object.
     * @return a state object which encapsulates the provided argument, with a
     * nothing value.
     */
    public static <S> State<Nothing, S> set(S s) {
        return new State<>(x -> Tuple.create(Nothing.instance, s));
    }

    /**
     * An alias for sequence method.
     * @param fs : List of state functions.
     * @param <S> : The type parameter of the state object.
     * @param <A> : Type parameter of the values generated.
     * @return the list of values generated after calling the state functions.
     */
    public static <S, A> State<List<A>, S> compose(List<State<A, S>> fs) {
        return sequence(fs);
    }

    /**
     * Convenience method to return a value after applying the given state.
     * @param s : The state object, which will be applied to the state generator.
     * @return the value after applying the state.
     */
    public A eval(S s) {
        return run.apply(s)._1;
    }
}
